{"version":3,"file":"map-gl-indoor.umd.min.js","sources":["../src/IndoorControl.ts","../src/Utils.ts","../src/Indoor.ts","../src/style/DefaultLayers.ts","../src/style/index.ts","../node_modules/@turf/helpers/index.js","../node_modules/@turf/meta/index.js","../node_modules/@turf/bbox/index.js","../src/IndoorMap.ts","../src/GeojsonHelper.ts","../src/MapServerHandler.ts","../src/index.ts"],"sourcesContent":["import Indoor from './Indoor';\nimport IndoorMap from './IndoorMap';\n\nimport type { Map } from 'mapbox-gl';\nimport type { Level } from './types';\n\n/**\n * Creates a indoor control with floors buttons\n\n * @implements {IControl}\n */\nclass IndoorControl {\n\n    _indoor: Indoor;\n    _map: Map;\n    _indoorMap: IndoorMap | null;\n\n    _container: HTMLElement | null;\n    _levelsButtons: Array<HTMLElement>;\n    _selectedButton: HTMLElement | null;\n\n    constructor(indoor: Indoor) {\n        this._indoor = indoor;\n        this._levelsButtons = [];\n        this._container = null;\n        this._selectedButton = null;\n    }\n\n    onAdd(map: Map) {\n        this._map = map;\n\n        // Create container\n        this._container = document.createElement(\"div\");\n        this._container.classList.add(\"mapboxgl-ctrl\");\n        this._container.classList.add(\"mapboxgl-ctrl-group\");\n        this._container.style.display = 'none';\n        this._container.addEventListener('contextmenu', this._onContextMenu);\n\n        // If indoor layer is already loaded, update levels\n        this._indoorMap = this._indoor.getSelectedMap();\n        if (this._indoor.getSelectedMap() !== null) {\n            this._updateNavigationBar()\n            this._setSelected(this._indoor.getLevel());\n        }\n\n        // Register to indoor events\n        this._map.on('indoor.map.loaded', this._onMapLoaded);\n        this._map.on('indoor.map.unloaded', this._onMapUnLoaded);\n        this._map.on('indoor.level.changed', this._onLevelChanged);\n\n        return this._container;\n    }\n\n    onRemove() {\n        this._container.remove();\n        this._container = null;\n        this._map.off('indoor.map.loaded', this._onMapLoaded);\n        this._map.off('indoor.map.unloaded', this._onMapUnLoaded);\n        this._map.off('indoor.level.changed', this._onLevelChanged);\n    }\n\n    _onMapLoaded = ({ indoorMap }: { indoorMap: IndoorMap }): void => {\n        this._indoorMap = indoorMap;\n        this._updateNavigationBar();\n        this._setSelected(this._indoor.getLevel());\n    }\n\n    _onMapUnLoaded = (): void => {\n        this._indoorMap = null;\n        this._updateNavigationBar();\n    }\n\n    _onLevelChanged = ({ level }: { level: Level | null }): void => this._setSelected(level);\n\n    _updateNavigationBar() {\n\n        if (this._container === null) {\n            return;\n        }\n\n        if (this._indoorMap === null) {\n            this._container.style.display = 'none';\n            return;\n        }\n\n        this._container.style.display = 'block';\n\n        this._levelsButtons = [];\n        while (this._container.firstChild) {\n            this._container.removeChild(this._container.firstChild);\n        }\n\n        const range = this._indoorMap.levelsRange;\n        for (let i = range.max; i >= range.min; i--) {\n            this._levelsButtons[i] = this._createLevelButton(this._container, i);\n        }\n    }\n\n    _setSelected(level: Level | null) {\n\n        if (this._levelsButtons.length === 0) {\n            return;\n        }\n\n        if (this._selectedButton) {\n            this._selectedButton.style.fontWeight = \"normal\";\n        }\n        if (level !== null && this._levelsButtons[level]) {\n            this._levelsButtons[level].style.fontWeight = \"bold\";\n            this._selectedButton = this._levelsButtons[level];\n        }\n    }\n\n    _createLevelButton(container: HTMLElement, level: Level) {\n        const a = document.createElement(\"button\");\n        a.innerHTML = level.toString();\n        a.classList.add(\"mapboxgl-ctrl-icon\");\n        container.appendChild(a);\n        a.addEventListener('click', () => {\n            this._map.fire('indoor.control.clicked', { level });\n            if (this._indoor.getLevel() === level) return;\n            this._indoor.setLevel(level);\n        });\n        return a;\n    }\n\n    _onContextMenu(e: Event) {\n        e.preventDefault();\n    }\n\n}\n\nexport default IndoorControl;\n","import { LngLat, LngLatBounds } from 'mapbox-gl';\n\nimport type { FilterSpecification, Level } from './types';\n\nexport const EarthRadius = 6371008.8;\n\nexport function overlap(bounds1: LngLatBounds, bounds2: LngLatBounds) {\n\n    // If one rectangle is on left side of other\n    if (bounds1.getWest() > bounds2.getEast() || bounds2.getWest() > bounds1.getEast()) {\n        return false;\n    }\n\n    // If one rectangle is above other\n    if (bounds1.getNorth() < bounds2.getSouth() || bounds2.getNorth() < bounds1.getSouth()) {\n        return false;\n    }\n\n    return true;\n}\n\nexport function filterWithLevel(initialFilter: FilterSpecification, level: Level, showFeaturesWithEmptyLevel: boolean = false): any {\n    return [\n        \"all\",\n        initialFilter,\n        [\n            'any',\n            showFeaturesWithEmptyLevel ? [\"!\", [\"has\", \"level\"]] : false,\n            [\n                'all',\n                [\n                    \"has\",\n                    \"level\"\n                ],\n                [\n                    \"any\",\n                    [\n                        \"==\",\n                        [\"get\", \"level\"],\n                        level.toString()\n                    ],\n                    [\n                        \"all\",\n                        [\n                            \"!=\",\n                            [\n                                \"index-of\",\n                                \";\",\n                                [\"get\", \"level\"]\n                            ],\n                            -1,\n                        ],\n                        [\n                            \">=\",\n                            level,\n                            [\n                                \"to-number\",\n                                [\n                                    \"slice\",\n                                    [\"get\", \"level\"],\n                                    0,\n                                    [\n                                        \"index-of\",\n                                        \";\",\n                                        [\"get\", \"level\"]\n                                    ]\n                                ]\n                            ]\n                        ],\n                        [\n                            \"<=\",\n                            level,\n                            [\n                                \"to-number\",\n                                [\n                                    \"slice\",\n                                    [\"get\", \"level\"],\n                                    [\n                                        \"+\",\n                                        [\n                                            \"index-of\",\n                                            \";\",\n                                            [\"get\", \"level\"]\n                                        ],\n                                        1\n                                    ]\n                                ]\n                            ]\n                        ]\n                    ]\n                ]\n            ]\n        ]\n    ];\n}\n\n\nexport function destinationPoint(start: LngLat, distance: number, bearing: number) : LngLat {\n    const dR = distance / EarthRadius;\n    const cosDr = Math.cos(dR);\n    const sinDr = Math.sin(dR);\n\n    const phi1 = start.lat / 180 * Math.PI;\n    const lambda1 = start.lng / 180 * Math.PI;\n\n    const phi2 = Math.asin( Math.sin(phi1) * cosDr\n        + Math.cos(phi1) * sinDr * Math.cos(bearing)\n    );\n    const lambda2 = lambda1 + Math.atan2(\n        Math.sin(bearing) * sinDr * Math.cos(phi1),\n        cosDr - Math.sin(phi1) * Math.sin(phi2)\n    );\n\n    return new LngLat(lambda2 * 180 / Math.PI, phi2 * 180 / Math.PI);\n}\n\nexport function distance(point1: LngLat, point2: LngLat) : number {\n\n    const lat1 = point1.lat / 180 * Math.PI;\n    const lng1 = point1.lng / 180 * Math.PI;\n\n    const lat2 = point2.lat / 180 * Math.PI;\n    const lng2 = point2.lng / 180 * Math.PI;\n\n    const dlat = lat2 - lat1;\n    const dlng = lng2 - lng1;\n\n    const angle = Math.sin(dlat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlng / 2) ** 2;\n\n    const tangy = Math.sqrt(angle);\n    const tangx = Math.sqrt(1 - angle);\n    const cosn = 2 * Math.atan2(tangy, tangx);\n\n    return EarthRadius * cosn;\n}\n","import IndoorMap from './IndoorMap';\nimport IndoorControl from './IndoorControl';\nimport { overlap, filterWithLevel, distance } from './Utils';\n\ntype SavedFilter = {\n    layerId: string,\n    filter: FilterSpecification\n}\n\nimport type { Map } from 'mapbox-gl';\nimport type { Level, FilterSpecification, LayerSpecification } from './types';\n\nconst SOURCE_ID = 'indoor';\n\n/**\n * Manage indoor levels\n * @param {Map} map the Mapbox map\n */\nclass Indoor {\n\n    _map: Map;\n    _level: Level | null;\n\n    _indoorMaps: Array<IndoorMap>;\n    _selectedMap: IndoorMap | null;\n    _previousSelectedMap: IndoorMap | null;\n    _previousSelectedLevel: Level | null;\n\n    _savedFilters: Array<SavedFilter>;\n    _mapLoaded: boolean;\n\n    _control: IndoorControl;\n\n    _updateMapPromise: Promise<void>;\n\n    constructor(map: Map) {\n        this._map = map;\n        this._level = null;\n\n        this._indoorMaps = [];\n        this._savedFilters = [];\n        this._selectedMap = null;\n        this._previousSelectedMap = null;\n        this._previousSelectedLevel = null;\n        this._mapLoaded = false;\n        this._updateMapPromise = Promise.resolve();\n\n        this._control = new IndoorControl(this);\n\n        if (this._map.loaded()) {\n            this._mapLoaded = true;\n        } else {\n            this._map.on('load', () => {\n                this._mapLoaded = true;\n                this._updateSelectedMapIfNeeded();\n            });\n        }\n\n        this._map.on('moveend', () => this._updateSelectedMapIfNeeded());\n    }\n\n    getSelectedMap(): IndoorMap | null {\n        return this._selectedMap;\n    }\n\n    getLevel(): Level | null {\n        return this._level;\n    }\n\n    setLevel(level: Level | null, fireEvent: Boolean = true): void {\n\n        if (this._selectedMap === null) {\n            throw new Error('Cannot set level, no map has been selected');\n        }\n\n        this._level = level;\n        this._updateFiltering();\n        if (fireEvent) {\n            this._map.fire('indoor.level.changed', { level });\n        }\n    }\n\n    get control(): IndoorControl {\n        return this._control;\n    }\n\n    /**\n     * ***********************\n     * Handle level change\n     * ***********************\n     */\n\n    _addLayerForFiltering(layer: LayerSpecification, beforeLayerId?: string) {\n        this._map.addLayer(layer, beforeLayerId);\n        this._savedFilters.push({\n            layerId: layer.id,\n            filter: this._map.getFilter(layer.id) || [\"all\"]\n        });\n    }\n\n    _removeLayerForFiltering(layerId: string) {\n        this._savedFilters = this._savedFilters.filter(({ layerId: id }) => layerId !== id);\n        this._map.removeLayer(layerId);\n    }\n\n    _updateFiltering() {\n        const level = this._level;\n\n        let filterFn: (filter: FilterSpecification) => FilterSpecification;\n        if (level !== null) {\n            const showFeaturesWithEmptyLevel = this._selectedMap ? this._selectedMap.showFeaturesWithEmptyLevel : false;\n            filterFn = (filter: FilterSpecification) => filterWithLevel(filter, level, showFeaturesWithEmptyLevel);\n        } else {\n            filterFn = (filter: FilterSpecification): FilterSpecification => filter;\n        }\n\n        this._savedFilters.forEach(({ layerId, filter }) => this._map.setFilter(layerId, filterFn(filter)));\n    }\n\n\n\n    /**\n     * **************\n     * Handle maps\n     * **************\n     */\n\n    addMap(map: IndoorMap) {\n        this._indoorMaps.push(map);\n        this._updateSelectedMapIfNeeded();\n    }\n\n    removeMap(map: IndoorMap) {\n        this._indoorMaps = this._indoorMaps.filter(_indoorMap => _indoorMap !== map);\n        this._updateSelectedMapIfNeeded();\n    }\n\n\n    async _updateSelectedMapIfNeeded() {\n\n        if (!this._mapLoaded) {\n            return;\n        }\n\n        // Avoid to call \"closestMap\" or \"updateSelectedMap\" if the previous call is not finished yet\n        await this._updateMapPromise;\n        this._updateMapPromise = (async () => {\n            const closestMap = this._closestMap();\n            if (closestMap !== this._selectedMap) {\n                this._updateSelectedMap(closestMap);\n            }\n        })();\n    }\n\n    _updateSelectedMap(indoorMap: IndoorMap | null) {\n\n        const previousMap = this._selectedMap;\n\n        // Remove the previous selected map if it exists\n        if (previousMap !== null) {\n            previousMap.layersToHide.forEach(layerId => this._map.setLayoutProperty(layerId, 'visibility', 'visible'));\n            previousMap.layers.forEach(({ id }) => this._removeLayerForFiltering(id));\n            this._map.removeSource(SOURCE_ID);\n\n            if (!indoorMap) {\n                // Save the previous map level.\n                // It enables the user to exit and re-enter, keeping the same level shown.\n                this._previousSelectedLevel = this._level;\n                this._previousSelectedMap = previousMap;\n            }\n\n            this.setLevel(null, false);\n            this._map.fire('indoor.map.unloaded', { indoorMap: previousMap });\n        }\n\n        this._selectedMap = indoorMap;\n        if (!indoorMap) {\n            return;\n        }\n\n        const { geojson, layers, levelsRange, beforeLayerId } = indoorMap;\n\n        // Add map source\n        this._map.addSource(SOURCE_ID, {\n            type: \"geojson\",\n            data: geojson\n        });\n\n        // Add layers and save filters\n        layers.forEach(layer => this._addLayerForFiltering(layer, beforeLayerId));\n\n        // Hide layers which can overlap for rendering\n        indoorMap.layersToHide.forEach(layerId => this._map.setLayoutProperty(layerId, 'visibility', 'none'));\n\n        // Restore the same level when the previous selected map is the same.\n        const level = this._previousSelectedMap === indoorMap\n            ? this._previousSelectedLevel\n            : Math.max(Math.min(indoorMap.defaultLevel, levelsRange.max), levelsRange.min)\n\n        this.setLevel(level, false);\n\n        this._map.fire('indoor.map.loaded', { indoorMap });\n    }\n\n    _closestMap() {\n\n        // TODO enhance this condition\n        if (this._map.getZoom() < 17) {\n            return null;\n        }\n\n        const cameraBounds = this._map.getBounds();\n        const mapsInBounds = this._indoorMaps.filter(indoorMap =>\n            overlap(indoorMap.bounds, cameraBounds)\n        );\n\n        if (mapsInBounds.length === 0) {\n            return null;\n        }\n\n        if (mapsInBounds.length === 1) {\n            return mapsInBounds[0];\n        }\n\n        /*\n         * If there is multiple maps at this step, select the closest\n         */\n        let minDist = Number.POSITIVE_INFINITY;\n        let closestMap = mapsInBounds[0];\n        for (const map of mapsInBounds) {\n            const _dist = distance(map.bounds.getCenter(), cameraBounds.getCenter());\n            if (_dist < minDist) {\n                closestMap = map;\n                minDist = _dist;\n            }\n        }\n        return closestMap;\n    }\n\n}\n\nexport default Indoor;\n\n","import defaultLayers from './default_layers.json';\n\nimport type { LayerSpecification } from '../types';\n\nlet layers: Array<LayerSpecification> = defaultLayers;\n\n/**\n * Transform the generic \"poi-indoor\" layer into multiple layers using filters based on OSM tags\n */\n\nconst POI_LAYER_ID = \"poi-indoor\";\n\nconst OSM_FILTER_MAPBOX_MAKI_LIST = [\n    {\n        filter: ['filter-==', 'amenity', 'fast_food'],\n        maki: 'fast-food'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'restaurant'],\n        maki: 'restaurant'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'cafe'],\n        maki: 'cafe'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'bank'],\n        maki: 'bank'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'toilets'],\n        maki: 'toilet'\n    },\n    {\n        filter: ['filter-==', 'shop', 'travel_agency'],\n        maki: 'suitcase'\n    },\n    {\n        filter: ['filter-==', 'shop', 'convenience'],\n        maki: 'grocery'\n    },\n    {\n        filter: ['filter-==', 'shop', 'bakery'],\n        maki: 'bakery'\n    },\n    {\n        filter: ['filter-==', 'shop', 'chemist'],\n        maki: 'pharmacy'\n    },\n    {\n        filter: ['filter-==', 'shop', 'clothes'],\n        maki: 'clothing-store'\n    },\n    {\n        filter: ['filter-==', 'highway', 'steps'],\n        maki: 'entrance'\n    },\n    {\n        filter: ['has', 'shop'],\n        maki: 'shop'\n    }\n];\n\nfunction createPoiLayers(metaLayer: LayerSpecification): Array<LayerSpecification> {\n    return OSM_FILTER_MAPBOX_MAKI_LIST.map(poi => {\n        const newLayer = Object.assign({}, metaLayer);\n        newLayer.id += `-${poi.maki}`;\n        newLayer.filter = poi.filter;\n        newLayer.layout = Object.assign({}, metaLayer.layout);\n        newLayer.layout['icon-image'] = `${poi.maki}-15`;\n        return newLayer;\n    });\n}\n\nconst poiLayer = layers.find(layer => layer.id === POI_LAYER_ID);\nif (poiLayer) {\n    // Convert poi-indoor layer into several poi-layers\n    createPoiLayers(poiLayer).forEach(_layer => layers.push(_layer));\n    layers = layers.filter(layer => layer.id !== POI_LAYER_ID);\n}\n\nexport default layers;\n","import DefaultLayers from './DefaultLayers';\n\nexport default { DefaultLayers };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","import Style from './style';\nimport GeoJsonHelper from './GeojsonHelper';\n\nimport type { GeoJSON } from 'geojson';\n\nimport type { LevelsRange, IndoorMapOptions, LayerSpecification } from './types';\nimport type { LngLatBounds } from 'mapbox-gl';\n\nclass IndoorMap {\n\n    bounds: LngLatBounds;\n    geojson: any;\n    layers: Array<LayerSpecification>;\n    levelsRange: LevelsRange;\n    beforeLayerId?: string;\n    layersToHide: Array<string>;\n    defaultLevel: number;\n    showFeaturesWithEmptyLevel: boolean;\n\n    static fromGeojson(geojson: GeoJSON, options: IndoorMapOptions = {}) {\n\n        const { bounds, levelsRange } = GeoJsonHelper.extractLevelsRangeAndBounds(geojson);\n\n        const map = new IndoorMap();\n        map.geojson = geojson;\n        map.layers = options.layers ? options.layers : Style.DefaultLayers;\n        map.bounds = bounds;\n        map.levelsRange = levelsRange;\n        map.layersToHide = options.layersToHide ? options.layersToHide : [];\n        map.beforeLayerId = options.beforeLayerId;\n        map.defaultLevel = options.defaultLevel ? options.defaultLevel : 0;\n        map.showFeaturesWithEmptyLevel = options.showFeaturesWithEmptyLevel ? options.showFeaturesWithEmptyLevel : false;\n\n        return map;\n    }\n\n}\n\nexport default IndoorMap;\n","import { LngLatBounds } from 'mapbox-gl';\nimport bbox from '@turf/bbox';\n\nimport type { Feature, GeoJSON } from 'geojson';\nimport type { LevelsRange } from './types';\n\n/**\n * Helper for Geojson data\n */\nclass GeoJsonHelper {\n\n    /**\n     * Extract level from feature\n     *\n     * @param {GeoJSONFeature} feature geojson feature\n     * @returns {LevelsRange | number | null} the level or the range of level.\n     */\n    static extractLevelFromFeature(feature: Feature): (LevelsRange | number | null) {\n        if (!!feature.properties &&\n            feature.properties.level !== null) {\n            const propertyLevel = feature.properties['level'];\n            if (typeof propertyLevel === 'string') {\n                const splitLevel = propertyLevel.split(';');\n                if (splitLevel.length === 1) {\n                    const level = parseFloat(propertyLevel);\n                    if (!isNaN(level)) {\n                        return level;\n                    }\n                } else if (splitLevel.length === 2) {\n                    const level1 = parseFloat(splitLevel[0]);\n                    const level2 = parseFloat(splitLevel[1]);\n                    if (!isNaN(level1) && !isNaN(level2)) {\n                        return {\n                            min: Math.min(level1, level2),\n                            max: Math.max(level1, level2)\n                        };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract levels range and bounds from geojson\n     *\n     * @param {GeoJSON} geojson the geojson\n     * @returns {Object} the levels range and bounds.\n     */\n    static extractLevelsRangeAndBounds(geojson: GeoJSON): ({ levelsRange: LevelsRange, bounds: LngLatBounds }) {\n\n        let minLevel = Infinity;\n        let maxLevel = -Infinity;\n\n        const boundsFromTurf = <[number, number, number, number]>bbox(geojson).slice(0, 4);\n        const bounds = new LngLatBounds(boundsFromTurf);\n\n        const parseFeature = (feature: Feature): void => {\n            const level = this.extractLevelFromFeature(feature);\n            if (level === null) {\n                return;\n            }\n            if (typeof level === 'number') {\n                minLevel = Math.min(minLevel, level);\n                maxLevel = Math.max(maxLevel, level);\n            } else if (typeof level === 'object') {\n                minLevel = Math.min(minLevel, level.min);\n                maxLevel = Math.max(maxLevel, level.max);\n            }\n        };\n\n        if (geojson.type === 'FeatureCollection') {\n            geojson.features.forEach(parseFeature);\n        } else if (geojson.type === 'Feature') {\n            parseFeature(geojson);\n        }\n\n        if (minLevel === Infinity || maxLevel === -Infinity) {\n            throw new Error('No level found');\n        }\n        return {\n            levelsRange: { min: minLevel, max: maxLevel },\n            bounds\n        };\n    }\n}\nexport default GeoJsonHelper;\n","import { LngLatBounds } from 'mapbox-gl';\n\nimport IndoorMap from './IndoorMap';\nimport { destinationPoint, distance } from './Utils';\n\nimport type { Map as MapboxMap } from 'mapbox-gl';\nimport type Indoor from './Indoor';\nimport type { IndoorMapOptions } from './types';\n\ntype Map = MapboxMap & {\n    indoor?: Indoor\n};\n\ntype RemoteMap = {\n    name: string,\n    path: string,\n    indoorMap?: IndoorMap\n}\n\nconst MIN_ZOOM_TO_DOWNLOAD = 17;\nconst AREA_TO_DOWNLOAD = 1000; // in terms of distance from user\n\nclass MapServerHandler {\n\n    serverUrl: string;\n\n    map: Map;\n    remoteMapsDownloaded: RemoteMap[];\n    downloadedBounds: LngLatBounds | null;\n\n    loadMapsPromise: Promise<void> = Promise.resolve();\n\n    indoorMapOptions: IndoorMapOptions;\n\n    private constructor(serverUrl: string, map: Map, indoorMapOptions? : IndoorMapOptions) {\n        this.serverUrl = serverUrl;\n        this.map = map;\n        this.indoorMapOptions = indoorMapOptions;\n        this.remoteMapsDownloaded = [];\n        this.downloadedBounds = null;\n\n        if (map.loaded) {\n            this.loadMapsIfNecessary();\n        } else {\n            map.on('load', () => this.loadMapsIfNecessary())\n        }\n        map.on('move', () => this.loadMapsIfNecessary());\n    }\n\n    private loadMapsIfNecessary = async () => {\n\n        if (this.map.getZoom() < MIN_ZOOM_TO_DOWNLOAD) {\n            return;\n        }\n\n        const viewPort = this.map.getBounds();\n        if (this.downloadedBounds !== null) {\n            if (this.downloadedBounds.contains(viewPort.getNorthEast()) &&\n                this.downloadedBounds.contains(viewPort.getSouthWest())) {\n                // Maps of the viewport have already been downloaded.\n                return;\n            }\n        }\n\n        const distanceEastWest = distance(viewPort.getNorthEast(), viewPort.getNorthWest());\n        const distanceNorthSouth = distance(viewPort.getNorthEast(), viewPort.getSouthEast());\n        // It is not necessary to compute others as we are at zoom >= 17, the approximation is enough.\n        const maxDistanceOnScreen = Math.max(distanceEastWest, distanceNorthSouth);\n        const bestSizeOfAreaToDownload = Math.max(AREA_TO_DOWNLOAD, maxDistanceOnScreen * 2);\n\n        const center = this.map.getCenter();\n        const dist = bestSizeOfAreaToDownload * Math.sqrt(2);\n        const northEast = destinationPoint(center, dist, Math.PI / 4);\n        const southWest = destinationPoint(center, dist, - 3 * Math.PI / 4);\n        const boundsToDownload = new LngLatBounds(southWest, northEast);\n\n        // TODO: I put this here because fetch is async and takes more time than the next call to loadMapsIfNecessary.\n        this.downloadedBounds = boundsToDownload;\n\n        await this.loadMapsPromise;\n        this.loadMapsPromise = this.loadMapsInBounds(boundsToDownload);\n    }\n\n    private loadMapsInBounds = async (bounds: LngLatBounds) => {\n        const url = this.serverUrl + `/maps-in-bounds/${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;\n        const maps = await (await fetch(url)).json();\n\n        const mapsToRemove = this.remoteMapsDownloaded.reduce((acc, map) => {\n            if (!maps.find(_map => _map.path === map.path)) {\n                acc.push(map);\n            }\n            return acc;\n        }, []);\n\n        const mapsToAdd = maps.reduce((acc, map) => {\n            if (!this.remoteMapsDownloaded.find(_map => _map.path === map.path)) {\n                acc.push(map);\n            }\n            return acc;\n        }, []);\n\n        mapsToAdd.forEach(this.addCustomMap);\n        mapsToRemove.forEach(this.removeCustomMap);\n    };\n\n    private addCustomMap = async (map: RemoteMap) => {\n        const geojson = await (await fetch(this.serverUrl + map.path)).json();\n        map.indoorMap = IndoorMap.fromGeojson(geojson, this.indoorMapOptions);\n        this.map.indoor.addMap(map.indoorMap);\n        this.remoteMapsDownloaded.push(map);\n    };\n\n    private removeCustomMap = async (map: RemoteMap) => {\n        this.map.indoor.removeMap(map.indoorMap);\n        this.remoteMapsDownloaded.splice(this.remoteMapsDownloaded.indexOf(map), 1);\n    }\n\n\n    static manage(server: string, map: Map, indoorMapOptions?: IndoorMapOptions) {\n        return new MapServerHandler(server, map, indoorMapOptions);\n    }\n\n}\n\nexport default MapServerHandler;\n","import mapboxgl from 'mapbox-gl';\n\nimport Indoor from './Indoor';\nimport IndoorMap from './IndoorMap';\nimport MapServerHandler from './MapServerHandler';\nimport DefaultStyle from './style';\n\nObject.defineProperty(\n    mapboxgl.Map.prototype,\n    'indoor',\n    {\n        get: function () {\n            if (!this._indoor) {\n                this._indoor = new Indoor(this);\n            }\n            return this._indoor;\n        }\n    });\n\n\nexport { IndoorMap, MapServerHandler, DefaultStyle };\n"],"names":["IndoorControl","[object Object]","indoor","this","indoorMap","_indoorMap","_updateNavigationBar","_setSelected","_indoor","getLevel","level","_levelsButtons","_container","_selectedButton","map","_map","document","createElement","classList","add","style","display","addEventListener","_onContextMenu","getSelectedMap","on","_onMapLoaded","_onMapUnLoaded","_onLevelChanged","remove","off","firstChild","removeChild","range","levelsRange","i","max","min","_createLevelButton","length","fontWeight","container","a","innerHTML","toString","appendChild","fire","setLevel","e","preventDefault","EarthRadius","destinationPoint","start","distance","bearing","dR","cosDr","Math","cos","sinDr","sin","phi1","lat","PI","lambda1","lng","phi2","asin","lambda2","atan2","LngLat","point1","point2","lat1","lng1","lat2","dlat","dlng","angle","tangy","sqrt","tangx","cosn","SOURCE_ID","Indoor","_level","_indoorMaps","_savedFilters","_selectedMap","_previousSelectedMap","_previousSelectedLevel","_mapLoaded","_updateMapPromise","Promise","resolve","_control","loaded","_updateSelectedMapIfNeeded","fireEvent","Error","_updateFiltering","control","layer","beforeLayerId","addLayer","push","layerId","id","filter","getFilter","removeLayer","filterFn","showFeaturesWithEmptyLevel","initialFilter","filterWithLevel","forEach","setFilter","closestMap","_closestMap","_updateSelectedMap","previousMap","layersToHide","setLayoutProperty","layers","_removeLayerForFiltering","removeSource","geojson","addSource","type","data","_addLayerForFiltering","defaultLevel","getZoom","cameraBounds","getBounds","mapsInBounds","overlap","bounds1","bounds","bounds2","getWest","getEast","getNorth","getSouth","minDist","Number","POSITIVE_INFINITY","_dist","getCenter","POI_LAYER_ID","OSM_FILTER_MAPBOX_MAKI_LIST","maki","poiLayer","find","metaLayer","poi","newLayer","Object","assign","layout","_layer","DefaultLayers","feature","geom","properties","options","feat","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","ring","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","exports","factors","lengthToRadians","radiansToDegrees","isNumber","num","isNaN","Array","isArray","test","defineProperty","value","centimeters","earthRadius","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","acres","coords","geometries","precision","multiplier","pow","round","originalUnit","finalUnit","area","startFactor","areaFactors","finalFactor","input","constructor","indexOf","coordEach","callback","excludeWrapCoord","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","g","featureProperties","featureBBox","featureId","undefined","flattenEach","helpers","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","initialValue","previousValue","currentProperties","currentFeature","coord","currentGeometry","started","currentLine","isObject","result","Infinity","meta_1","IndoorMap","propertyLevel","splitLevel","split","parseFloat","level1","level2","minLevel","maxLevel","boundsFromTurf","slice","LngLatBounds","parseFeature","extractLevelFromFeature","extractLevelsRangeAndBounds","Style","MapServerHandler","serverUrl","indoorMapOptions","async","viewPort","downloadedBounds","contains","getNorthEast","getSouthWest","distanceEastWest","getNorthWest","distanceNorthSouth","getSouthEast","maxDistanceOnScreen","bestSizeOfAreaToDownload","center","dist","northEast","southWest","boundsToDownload","loadMapsPromise","loadMapsInBounds","url","maps","fetch","json","mapsToRemove","remoteMapsDownloaded","reduce","acc","path","addCustomMap","removeCustomMap","fromGeojson","addMap","removeMap","splice","loadMapsIfNecessary","server","mapboxgl","Map","prototype","get"],"mappings":"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"}